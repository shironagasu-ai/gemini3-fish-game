<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Sea Predator - Time Attack</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            background: radial-gradient(circle at center, #1a2a40 0%, #000000 100%);
            touch-action: none; /* スマホでのピンチインなどを無効化 */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }
        .stat-item {
            font-size: 1rem;
            margin-top: 5px;
            text-shadow: 0 0 4px #000;
        }
        /* タイム表示用のスタイル */
        #timer-display {
            font-size: 1.5rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            color: #fff;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #00ffff;
        }
        .highlight {
            color: #ff4d4d;
            font-weight: bold;
        }
        /* リザルト画面 */
        #restart-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 20;
            width: 100%;
        }
        #game-over-text {
            color: white;
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(255, 50, 50, 0.8);
            letter-spacing: 0.1em;
        }
        #final-time {
            color: #00ffff;
            font-size: 3rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        #restart-btn {
            background: rgba(0,0,0,0.6);
            color: white;
            border: 2px solid white;
            padding: 15px 50px;
            font-size: 1.2rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            transition: 0.3s;
            border-radius: 30px;
            pointer-events: auto; /* コンテナがwidth100%なのでここだけ有効化 */
        }
        #restart-btn:hover {
            background: white;
            color: black;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }
        
        /* スマホ向け調整 */
        @media (max-width: 600px) {
            #ui-layer { top: 10px; left: 10px; }
            #timer-display { font-size: 1.2rem; }
            .stat-item { font-size: 0.8rem; }
            #game-over-text { font-size: 1.8rem; }
            #final-time { font-size: 2rem; }
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="timer-display">00:00.00</div>
        <div class="stat-item">小魚: <span id="fish-count" class="highlight">0</span></div>
        <div class="stat-item">ボス: <span id="boss-size" class="highlight">0</span></div>
    </div>

    <div id="restart-container">
        <div id="game-over-text">ALL FISH EATEN</div>
        <div id="final-time">00:00.00</div>
        <button id="restart-btn">RESTART</button>
    </div>

    <canvas id="world"></canvas>

<script>
/**
 * ベクトル計算クラス
 */
class Vector {
    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    div(n) { return new Vector(this.x / n, this.y / n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        let m = this.mag();
        return m > 0 ? this.div(m) : new Vector(0, 0);
    }
    limit(max) {
        if (this.mag() > max) return this.normalize().mult(max);
        return this;
    }
    static dist(v1, v2) {
        return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2));
    }
}

/**
 * 魚の基本クラス
 */
class Fish {
    constructor(x, y) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1);
        this.acc = new Vector(0, 0);
        this.maxSpeed = 4.0;
        this.angle = 0;
    }
    applyForce(force) {
        this.acc = this.acc.add(force);
    }
}

/**
 * 小魚 (Boid)
 */
class Boid extends Fish {
    constructor(x, y) {
        super(x, y);
        this.maxSpeed = 4.5;
        this.maxForce = 0.2;
        this.r = 6.0;
        this.perceptionRadius = 80;
        const hue = Math.random() * 60 + 160; 
        this.color = `hsl(${hue}, 80%, 60%)`;
    }

    // w, h は「論理的な」画面サイズ
    update(boids, mousePos, w, h) {
        this.flock(boids, mousePos);
        this.checkEdges(w, h);
        
        this.vel = this.vel.add(this.acc);
        if (this.vel.mag() > this.maxSpeed) {
            this.vel = this.vel.normalize().mult(this.maxSpeed);
        }
        this.pos = this.pos.add(this.vel);
        this.acc = new Vector(0, 0);

        this.angle = Math.atan2(this.vel.y, this.vel.x);
    }

    flock(boids, mousePos) {
        let separation = new Vector(0,0);
        let alignment = new Vector(0,0);
        let cohesion = new Vector(0,0);
        let flee = new Vector(0,0);

        let total = 0;
        for (let other of boids) {
            let d = Vector.dist(this.pos, other.pos);
            if (other !== this && d < this.perceptionRadius) {
                if (d < this.perceptionRadius / 1.5) {
                    let diff = this.pos.sub(other.pos).normalize().div(d);
                    separation = separation.add(diff);
                }
                alignment = alignment.add(other.vel);
                cohesion = cohesion.add(other.pos);
                total++;
            }
        }

        if (total > 0) {
            separation = separation.div(total).normalize().mult(this.maxSpeed).sub(this.vel).limit(this.maxForce);
            alignment = alignment.div(total).normalize().mult(this.maxSpeed).sub(this.vel).limit(this.maxForce);
            cohesion = cohesion.div(total).sub(this.pos).normalize().mult(this.maxSpeed).sub(this.vel).limit(this.maxForce);
        }

        if (mousePos) {
            let d = Vector.dist(this.pos, mousePos);
            // マウス回避半径
            if (d < 250) {
                let diff = this.pos.sub(mousePos).normalize();
                diff = diff.mult(this.maxSpeed * 2.5); // 一時的に超加速
                let steer = diff.sub(this.vel).limit(this.maxForce * 5); // 舵効きを最大に
                flee = steer;
            }
        }

        separation = separation.mult(2.2);
        alignment = alignment.mult(1.5);
        cohesion = cohesion.mult(1.8);
        flee = flee.mult(5.0); // 逃げる力

        this.applyForce(separation);
        this.applyForce(alignment);
        this.applyForce(cohesion);
        this.applyForce(flee);
    }

    checkEdges(w, h) {
        const margin = 100;
        let desired = null;
        if (this.pos.x < margin) desired = new Vector(this.maxSpeed, this.vel.y);
        else if (this.pos.x > w - margin) desired = new Vector(-this.maxSpeed, this.vel.y);
        if (this.pos.y < margin) desired = new Vector(this.vel.x, this.maxSpeed);
        else if (this.pos.y > h - margin) desired = new Vector(this.vel.x, -this.maxSpeed);

        if (desired) {
            desired = desired.normalize().mult(this.maxSpeed);
            let steer = desired.sub(this.vel).limit(0.8);
            this.applyForce(steer);
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle);
        ctx.beginPath();
        ctx.moveTo(this.r * 2, 0);
        ctx.lineTo(-this.r, -this.r + 3);
        ctx.lineTo(-this.r, this.r - 3);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
    }
}

/**
 * ボス魚
 */
class BossFish extends Fish {
    constructor(x, y) {
        super(x, y);
        this.r = 20.0;
        this.baseMaxSpeed = 3.5;
        this.maxSpeed = this.baseMaxSpeed;
        this.maxForce = 0.25;
        this.angle = 0;
        this.scale = 1.0;
        this.targetScale = 1.0;
        this.eatenCount = 0;
    }

    update(boids, w, h) {
        let closest = null;
        let recordDist = Infinity;
        for (let boid of boids) {
            let d = Vector.dist(this.pos, boid.pos);
            if (d < recordDist) {
                recordDist = d;
                closest = boid;
            }
        }
        if (closest) {
            let desired = closest.pos.sub(this.pos).normalize().mult(this.maxSpeed);
            let steer = desired.sub(this.vel).limit(this.maxForce);
            this.applyForce(steer);

            if (recordDist < this.r + closest.r) {
                const idx = boids.indexOf(closest);
                if (idx > -1) {
                    boids.splice(idx, 1);
                    createParticles(closest.pos.x, closest.pos.y, '255, 60, 60', 12);
                    this.eatenCount++;
                    this.r += 0.6;
                    this.maxSpeed = Math.max(1.8, this.baseMaxSpeed - (this.eatenCount * 0.04));
                    this.scale = 1.25;
                    this.targetScale = 1.0;
                    updateStats();
                }
            }
        }

        const margin = 100;
        let desired = null;
        if (this.pos.x < margin) desired = new Vector(this.maxSpeed, this.vel.y);
        else if (this.pos.x > w - margin) desired = new Vector(-this.maxSpeed, this.vel.y);
        if (this.pos.y < margin) desired = new Vector(this.vel.x, this.maxSpeed);
        else if (this.pos.y > h - margin) desired = new Vector(this.vel.x, -this.maxSpeed);
        
        if (desired) {
            desired = desired.normalize().mult(this.maxSpeed);
            let steer = desired.sub(this.vel).limit(0.5);
            this.applyForce(steer);
        }

        this.vel = this.vel.add(this.acc);
        this.vel.limit(this.maxSpeed);
        this.pos = this.pos.add(this.vel);
        this.acc = new Vector(0, 0);

        let targetAngle = Math.atan2(this.vel.y, this.vel.x);
        let diff = targetAngle - this.angle;
        while (diff < -Math.PI) diff += Math.PI * 2;
        while (diff > Math.PI) diff -= Math.PI * 2;
        this.angle += diff * 0.1;

        this.scale += (this.targetScale - this.scale) * 0.15;
        if (Math.abs(this.targetScale - this.scale) < 0.01) this.targetScale = 1.0;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle);
        ctx.scale(this.scale, this.scale);

        let grad = ctx.createRadialGradient(-5, -5, 0, 0, 0, this.r);
        grad.addColorStop(0, '#ff6666');
        grad.addColorStop(1, '#cc0000');
        
        ctx.beginPath();
        ctx.ellipse(0, 0, this.r * 2, this.r, 0, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.shadowBlur = 15;
        ctx.shadowColor = "rgba(255, 0, 0, 0.5)";
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.beginPath();
        ctx.arc(this.r, -this.r/3, this.r/3.5, 0, Math.PI*2);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.r + this.r/8, -this.r/3, this.r/8, 0, Math.PI*2);
        ctx.fillStyle = 'black';
        ctx.fill();
        ctx.restore();
    }
}

let particles = [];
let bubbles = [];

function createParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push({
            pos: new Vector(x, y),
            vel: new Vector(Math.random()*4-2, Math.random()*4-2),
            color: color,
            alpha: 1.0,
            size: Math.random()*3+2
        });
    }
}

// ===========================
// メイン制御・最適化・タイマー
// ===========================
let canvas, ctx;
let logicalWidth, logicalHeight; // 論理的なゲーム空間サイズ
let scaleFactor = 1;             // 画面サイズに合わせた拡大縮小率
const MIN_LOGICAL_WIDTH = 1000;  // 最低でもこの幅（ピクセル）分のフィールドを確保する

let flock = [];
let boss = null;
let mousePos = null;
let isGameOver = false;

// タイマー関連
let startTime = 0;
let finalTimeText = "00:00.00";

function init() {
    canvas = document.getElementById('world');
    ctx = canvas.getContext('2d');
    
    window.addEventListener('resize', resize);
    
    // マウス/タッチ座標を論理座標に変換する
    const handleInput = (clientX, clientY) => {
        // キャンバス上の実際のピクセル座標を取得（CSSスケーリングなどは通常ないが念のため）
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left);
        const y = (clientY - rect.top);
        // スケール逆変換して論理座標にする
        mousePos = new Vector(x / scaleFactor, y / scaleFactor);
    };

    canvas.addEventListener('mousemove', e => handleInput(e.clientX, e.clientY));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        handleInput(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});
    
    canvas.addEventListener('mouseleave', () => mousePos = null);
    canvas.addEventListener('touchend', () => mousePos = null);
    
    document.getElementById('restart-btn').addEventListener('click', resetGame);

    resize();
    resetGame();
    animate();
}

/**
 * 画面リサイズとスケーリング計算
 * スマホでもPCでも「最低限の広さ」を担保するロジック
 */
function resize() {
    // 物理的なキャンバスサイズはウィンドウいっぱいにする
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // スケール計算: 
    // 画面幅が MIN_LOGICAL_WIDTH より小さい場合、ズームアウト（scale < 1）して
    // 論理的な幅を MIN_LOGICAL_WIDTH に合わせる。
    // 画面幅が大きい場合は、1.0（等倍）で描画し、単に広いフィールドを見せる。
    if (canvas.width < MIN_LOGICAL_WIDTH) {
        scaleFactor = canvas.width / MIN_LOGICAL_WIDTH;
    } else {
        scaleFactor = 1; 
    }

    // 論理的なゲーム空間のサイズ
    logicalWidth = canvas.width / scaleFactor;
    logicalHeight = canvas.height / scaleFactor;
}

function resetGame() {
    isGameOver = false;
    document.getElementById('restart-container').style.display = 'none';
    
    flock = [];
    particles = [];
    bubbles = [];
    
    // 論理サイズに基づいて配置
    for (let i = 0; i < 120; i++) {
        flock.push(new Boid(Math.random() * logicalWidth, Math.random() * logicalHeight));
    }
    for (let i = 0; i < 50; i++) {
        bubbles.push({
            pos: new Vector(Math.random() * logicalWidth, Math.random() * logicalHeight),
            vel: new Vector(0, Math.random() * -1 - 0.5),
            size: Math.random() * 3 + 1,
            wobble: Math.random() * Math.PI * 2,
            alpha: Math.random() * 0.3 + 0.1
        });
    }
    boss = new BossFish(logicalWidth / 2, logicalHeight / 2);
    
    // タイマーリセット
    startTime = Date.now();
    updateStats();
}

function updateStats() {
    document.getElementById('fish-count').textContent = flock.length;
    document.getElementById('boss-size').textContent = boss ? Math.round(boss.r) : 0;
}

function updateTimer() {
    if (isGameOver) return;
    
    const now = Date.now();
    const elapsed = now - startTime;
    
    const min = Math.floor(elapsed / 60000);
    const sec = Math.floor((elapsed % 60000) / 1000);
    const ms = Math.floor((elapsed % 1000) / 10); // 2桁まで

    // ゼロ埋め
    const mStr = min.toString().padStart(2, '0');
    const sStr = sec.toString().padStart(2, '0');
    const msStr = ms.toString().padStart(2, '0');

    finalTimeText = `${mStr}:${sStr}.${msStr}`;
    document.getElementById('timer-display').textContent = finalTimeText;
}

function animate() {
    requestAnimationFrame(animate);

    updateTimer();

    // 描画設定の保存
    ctx.save();

    // 残像用のクリア（画面全体）
    // scaleする前に塗るか、scaleしてから塗るか。
    // 背景は物理ピクセル全域を塗りたいのでscale前が良いが、
    // ここでは全体一貫性のためにscale後に論理サイズを塗る方式をとる。
    
    // スケール適用：これ以降の描画座標系は「論理座標」になる
    ctx.scale(scaleFactor, scaleFactor);

    // 論理領域をクリア（残像）
    ctx.fillStyle = 'rgba(15, 21, 32, 0.3)';
    ctx.fillRect(0, 0, logicalWidth, logicalHeight);

    // 気泡
    for (let b of bubbles) {
        b.pos.y += b.vel.y;
        b.wobble += 0.05;
        b.pos.x += Math.sin(b.wobble) * 0.5;
        // 画面外リセット
        if (b.pos.y < -10) {
            b.pos.y = logicalHeight + 10;
            b.pos.x = Math.random() * logicalWidth;
        }
        ctx.fillStyle = `rgba(100, 150, 255, ${b.alpha})`;
        ctx.beginPath();
        ctx.arc(b.pos.x, b.pos.y, b.size, 0, Math.PI * 2);
        ctx.fill();
    }

    // パーティクル
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.pos = p.pos.add(p.vel);
        p.vel = p.vel.mult(0.95);
        p.alpha -= 0.03;
        
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = `rgb(${p.color})`;
        ctx.beginPath();
        ctx.arc(p.pos.x, p.pos.y, p.size, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
        
        if (p.alpha <= 0) particles.splice(i, 1);
    }

    // 小魚更新 (論理サイズを渡す)
    for (let boid of flock) {
        boid.update(flock, mousePos, logicalWidth, logicalHeight);
        boid.draw(ctx);
    }

    // ボス更新
    if (boss && flock.length > 0) {
        boss.update(flock, logicalWidth, logicalHeight);
        boss.draw(ctx);
    } else if (flock.length === 0 && !isGameOver) {
        // ゲームクリア処理
        isGameOver = true;
        document.getElementById('final-time').textContent = "TIME: " + finalTimeText;
        document.getElementById('restart-container').style.display = 'block';
    } else if (isGameOver && boss) {
        // 勝利時の徘徊
        boss.update([], logicalWidth, logicalHeight);
        boss.draw(ctx);
    }

    // スケール設定を元に戻す
    ctx.restore();
}

window.addEventListener('load', init);

</script>
</body>
</html>
